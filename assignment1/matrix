#!/usr/bin/env bash
#CS344 400 W2018
#Program 1 - matrices
#Illia Abdullaiev

#Check whether the first matrix should be read from a file or stdin.
#Give other variables names for readability purposes.
operation=$1
params=$#
fromStdin=0

#Create a folder for temporary files. Clean up any previous temp files.
rm -rf ./temp
mkdir temp

if [ -t 0 ]; then
    #If there is nothing in stdin, treat second and the third parameters as matrix files.
    matrix1=$2
    matrix2=$3
else
    #Set from stdin flag to true for future use.
    fromStdin=1

    #Create the temporary file to store the contents of stdin.
    tempFile="./temp/$$"

    #Write contents of stdin into the temporary file.
    while read -r line ; do
        echo $line >> $tempFile
    done

    #Point matrix1 to the temporary file.
    matrix1=$tempFile
fi

#Checks that matrix 1 file is readable before attempting to read it.
checkMatrix1File() {
    if ! [ -a $matrix1 ];
    then
        echo "$matrix1 does not exist!" >&2
        exit 500
    fi

    if ! [ -r $matrix1 ];
    then
        echo "$matrix1 is not readable!" >&2
        exit 500
    fi
}

#Same as above ^^.
checkMatrix2File() {
    if ! [ -a $matrix2 ];
    then
        echo "$matrix2 does not exist!" >&2
        exit 500
    fi

    if ! [ -r $matrix2 ]; then
        echo "$matrix2 is not readable!" >&2
        exit 500
    fi
}

#Checks that only one matrix has been passed as a parameter.
onlyOneParam() {
    if ((fromStdin > 0)); then
        if ((params != 1)); then
            echo "Illegal invocation. Number of parameters is invalid. Syntax: cat [MATRIX_FILE] | ./matrix" >&2
            exit 500
        fi
    else
        if (( params != 2 )); then
            echo "Illegal invocation. Number of parameters is invalid. Syntax: ./matrix [COMMAND] [MATRIX_FILE]" >&2
            exit 500
        fi
    fi
}

#Checks that only two matrices have been passed as parameters.
onlyTwoParams() {
  if ((params != 3 )); then
      echo "Illegal invocation. Number of parameters is invalid. Syntax: ./matrix [COMMAND] [MATRIX1_FILE] [MATRIX2_FILE]" >&2
      exit 500
  fi
}

#Checks if two matrices have the same dimensions.
matricesCompatibleForAddition() {
    m1Dimensions="$(dims $matrix1)"
    m2Dimensions="$(dims $matrix2)"

    if [[ "$m1Dimensions" != "$m2Dimensions" ]]; then
        echo "Two matrices should have the same dimensions for addition!" >&2
        exit 500
    fi
}

#Cheks if two matrices are compatible for multiplication.
#That is, if two matrices MxN and NxP have the same N, they're compatible.
matricesCompatibleForProduct() {
    m1Dimensions="$(dims $matrix1)"
    m2Dimensions="$(dims $matrix2)"

    #Last character of the string.
    N1=${m1Dimensions: -1}

    #First character of the string.
    N2=${m2Dimensions:0:1}

    if [[ "$N1" != "$N2" ]]; then
        echo "Two matrices MxN and NxP should have the same N for multiplication!" >&2
        exit 500
    fi
}

#Prints out the dimensions of the matrix.
dims() {
    lastLine=""
    rows=0
    columns=0

    #If the argument was passed to this function, use it as the matrix file.
    #Otherwise, use $matrix1 global variable.
    if (( $# == 1 )); then
        matrix=$1
    else
        matrix=$matrix1
    fi

    #Iterate over each line of the file to count the number of rows.
    while read -r line ; do
        lastLine=$line
        rows=$(expr $rows + 1)
    done < $matrix

    #Iterate over every number in the line to count the number of columns.
    for number in $lastLine
    do
        columns=$(expr $columns + 1)
    done

    echo "$rows $columns"
}

#Reflects the elements of the matrix along the main diagonal.
transpose() {
    echo $operation
}

#Returns a row with each element representing the mean of the corresponding column.
mean() {
    result=""
    tempFile="./temp/mean$$"
    m1Dims="$(dims)"
    rows=${m1Dims:0:1}
    cols=${m1Dims: -1}

    #Write all numbers into a temp file.
    while read -r row ; do
        for number in $row ; do
            echo $number >> $tempFile
        done
    done < $matrix1

    #Iterate over the numbers in the temp file to put them into temporary files representing each column
    count=0
    while read -r num ; do
        count=$(expr $count + 1)
        tempColFile="./temp/mean_col_$count"
        echo $num >> $tempColFile

        if (( $count == $cols )); then
            count=0
        fi
    done < $tempFile

    #Iterate over temp column files to calculate the mean of each column.
    for ((col=1;col<=$cols;col++)); do
        tempColFile="./temp/mean_col_$col"
        sum=0

        #Calucalte the sum of all the numbers in the column.
        while read -r num ; do
            sum=$(expr $sum + $num)
        done < $tempColFile

        average=$(expr $sum / $rows)

        #If this is the average of the first column, no need to add the space in front of it.
        if (( $col == 1 )); then
            result=$average
        else
            result="$result $average"
        fi
    done

    echo $result
}

#Returns a new matrix which is a result of adding two matrices element-wise.
#Returns an error if two matrices have different dimensions.
add() {
    matricesCompatibleForAddition
    echo $operation
}

#Produces an MxP matrix as a product of MxN and NxP matrices.
multiply() {
    matricesCompatibleForProduct
    echo $operation
}

#Invokes the right function based on operation passed as the first parameter to the script.
case "$1" in
    dims | transpose | mean)
        checkMatrix1File
        onlyOneParam
        $1
    ;;
    add | multiply)
        checkMatrix1File
        checkMatrix2File
        onlyTwoParams
        $1
    ;;
    *)
        echo "$1 is not supported. Syntax: ./matrix [dims | transpose | mean | add | multiply] [MATRIX_FILE1] [(MATRIX_FILE2)]" >&2
        exit 500
    ;;
esac
